// Copyright (c) 2017
// Author: Jeff Weisberg <jaw @ tcp4me.com>
// Created: 2018-Aug-10 15:08 (EDT)
// Function: control

package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"

	"golang.org/x/net/context"

	"github.com/jaw0/acgo/diag"

	"github.com/jaw0/yentablue/gclient"
	"github.com/jaw0/yentablue/info"
	"github.com/jaw0/yentablue/proto"
	"github.com/jaw0/yentablue/putstatus"
	ringcf "github.com/jaw0/yentablue/ring/config"
	"github.com/jaw0/yentablue/soty"
)

// commands:
//   shutdown
//   servers
//   get db
//   put db
//   shard db on|off
//   replicas db #
//   add db server
//   remove db server
//   replace db server server
//   set db param value
//   rebalance db
//   status db

// -h addr:port

var dl = diag.Logger("main")
var sinfo = make(map[string]*info.Server)
var ac *gclient.C

func main() {
	var addr string

	flag.StringVar(&addr, "h", "127.0.0.1:5301", "addr")
	flag.Parse()

	ac_, err := gclient.New(&gclient.GrpcConfig{
		Addr: []string{addr},
	})
	if err != nil {
		dl.Fatal("cannot connect to %s: %v\n", addr, err)
	}
	defer ac_.Close()
	ac = ac_

	// get server info
	getServers()

	args := flag.Args()

	if len(args) == 0 {
		return
	}

	switch args[0] {
	case "shutdown":
		shutdown()
	case "servers":
		showServers()
	case "get":
		cmdGet(args)
	case "put":
		cmdPut(args)
	case "shard":
		cmdShard(args)
	}

}

func getServers() error {

	res, err := ac.GetServersAll()

	if err != nil {
		dl.Fatal("%v", err)
	}

	for _, r := range res {
		id := r.Id
		sinfo[id] = r
		// fmt.Printf(">> %s\n", id)
	}

	return nil
}

func showServers() {

	// QQQ - format?
	for _, s := range sinfo {
		fmt.Printf("%+v\n", s)
	}
}

func getConf(db string) ([]byte, error) {

	res, err := ac.Get(&gclient.Datum{
		Map: "_conf",
		Key: db + ".cf",
	})

	if err != nil {
		dl.Fatal("cannot get config %v", err)
	}

	if len(res.Value) != 1 {
		return nil, nil
	}

	return res.Value, nil
}

//	if len(r.Value) == 0 {
//		return &config.Ring{}, nil
//	}
//
//	return config.FromBytes(r.Value)

func setConf(db string, cf []byte) {

	res, err := ac.Put(&gclient.Datum{
		Map:     "_conf",
		Key:     db + ".cf",
		Version: soty.Now(),
		Value:   cf,
	})

	if err != nil {
		dl.Fatal("cannot put config to server: %v", err)
	}

	if res != putstatus.DONE {
		dl.Fatal("cannot put config to server: code %d", res)

	}
}

func cmdGet(args []string) {

	if len(args) < 2 {
		dl.Fatal("get database")
	}

	cf, err := getConf(args[1])
	if err != nil {
		dl.Fatal("could not read cf: %v")
	}

	fmt.Printf("%s\n", cf)
}

func cmdPut(args []string) {

	if len(args) < 2 {
		dl.Fatal("get database")
	}

	// read cf from stdin
	cf, err := ioutil.ReadAll(os.Stdin)

	if err != nil {
		dl.Fatal("could not read cf: %v", err)
	}

	setConf(args[1], cf)

}

func shutdown() {

	_, err := ac.RPC().ShutDown(context.Background(), &acproto.ACPY2Empty{})

	if err != nil {
		dl.Fatal("cannot shut down server: %v", err)
	}
}

// synthesize an empty ring config
func emptyCf() []byte {

	rc := &ringcf.Ring{
		Parts: []ringcf.Part{
			{Shard: []uint32{0}},
		},
	}

	res, _ := ringcf.ToBytes(rc)
	res = append([]byte("# config not found\n# autogenerated example\n"), res...)
	return res
}

//################################################################

func argsDbServer(args []string) (string, string, *ringcf.Ring, error) {

	if len(args) < 3 {
		return "", "", nil, errors.New("arg missing")
	}

	dbname := args[1]
	server := args[2]

	if sinfo[server] == nil {
		dl.Verbose("WARNING: unknown server '%s'; typo or offline?", server)
	}

	dbcf, err := getConf(dbname)
	if err != nil {
		dl.Fatal("error: %v", err)
	}

	if dbcf == nil {
		return dbname, server, &ringcf.Ring{}, nil
	}
	rcf, err := ringcf.FromBytes(dbcf)
	if err != nil {
		dl.Fatal("error: %v", err)
	}

	return dbname, server, rcf, nil
}

//################################################################

func cmdShard(args []string) {

	dbname, server, rcf, err := argsDbServer(args)

	if err != nil {
		// RSN - usage
		dl.Fatal("error: %v", err)
	}

	dl.Verbose(">> %v %v %v", dbname, server, rcf)
}
