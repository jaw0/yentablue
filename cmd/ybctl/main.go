// Copyright (c) 2017
// Author: Jeff Weisberg <jaw @ tcp4me.com>
// Created: 2018-Aug-10 15:08 (EDT)
// Function: control

package main

import (
	"crypto/rand"
	"encoding/binary"
	"flag"
	"fmt"
	"io/ioutil"
	"math"
	"os"
	"strconv"

	"golang.org/x/net/context"

	"github.com/jaw0/acgo/diag"

	"github.com/jaw0/yentablue/gclient"
	"github.com/jaw0/yentablue/info"
	"github.com/jaw0/yentablue/proto"
	"github.com/jaw0/yentablue/putstatus"
	ringcf "github.com/jaw0/yentablue/ring/config"
	"github.com/jaw0/yentablue/soty"
)

// commands:
//   shutdown
//   servers
//   get db
//   put db
//   shard db on|off|auto|noauto|#replicas
//
//   status db

// -h addr:port

var dl = diag.Logger("main")
var sinfo = make(map[string]*info.Server)
var ac *gclient.C
var dryRun bool

func main() {
	var addr string

	flag.StringVar(&addr, "h", "127.0.0.1:5301", "addr")
	flag.BoolVar(&dryRun, "n", false, "dry run")
	flag.Parse()

	ac_, err := gclient.New(&gclient.GrpcConfig{
		Addr: []string{addr},
	})
	if err != nil {
		dl.Fatal("cannot connect to %s: %v\n", addr, err)
	}
	defer ac_.Close()
	ac = ac_

	// get server info
	getServers()

	args := flag.Args()

	if len(args) == 0 {
		return
	}

	switch args[0] {
	case "shutdown":
		shutdown()
	case "servers":
		showServers()
	case "get":
		cmdGet(args)
	case "put":
		cmdPut(args)
	case "shard":
		cmdShard(args)
	}

}

func getServers() error {

	res, err := ac.GetServersAll()

	if err != nil {
		dl.Fatal("%v", err)
	}

	for _, r := range res {
		id := r.Id
		sinfo[id] = r
		// fmt.Printf(">> %s\n", id)
	}

	return nil
}

func showServers() {

	fmt.Printf("%s %s %8s %8s %8s %8s %5s %5s %s\n", "  ", "  ", "Sys", "Env", "DC", "Rack", "CPU", "Avail", "Id")

	for _, s := range sinfo {
		//fmt.Printf("%+v\n", s)
		updn := "dn"
		dc := "-"
		rk := "-"
		utd := ".."

		if s.IsUp {
			updn = "up"
		}
		if s.Uptodate {
			utd = "ok"
		}
		if s.Datacenter != "" {
			dc = s.Datacenter
		}
		if s.Rack != "" {
			rk = s.Rack
		}

		// Hostname, TimeLastUp, TimeUpSince
		fmt.Printf("%s %s %8s %8s %8s %8s %5d %5d %s\n",
			updn, utd, s.Subsystem, s.Environment, dc, rk, s.CpuMetric, s.CapacityMetric, s.Id)
	}
}

func getConf(db string) ([]byte, uint64, error) {

	res, err := ac.Get(&gclient.Datum{
		Map: "_conf",
		Key: db + ".cf",
	})

	if err != nil {
		dl.Fatal("cannot get config %v", err)
	}

	if len(res.Value) < 1 {
		return nil, 0, nil
	}

	return res.Value, res.Version, nil
}

//	if len(r.Value) == 0 {
//		return &config.Ring{}, nil
//	}
//
//	return config.FromBytes(r.Value)

func setConf(db string, ver uint64, cf []byte) {

	res, err := ac.Put(&gclient.Datum{
		Map:       "_conf",
		Key:       db + ".cf",
		Version:   soty.Now(),
		IfVersion: ver,
		Value:     cf,
	})

	if err != nil {
		dl.Fatal("cannot put config to server: %v", err)
	}

	if res != putstatus.DONE {
		dl.Fatal("cannot put config to server: code %d", res)

	}
}

func cmdGet(args []string) {

	if len(args) < 2 {
		dl.Fatal("get database")
	}

	cf, _, err := getConf(args[1])
	if err != nil {
		dl.Fatal("could not read cf: %v")
	}

	fmt.Printf("%s\n", cf)
}

func cmdPut(args []string) {

	if len(args) < 2 {
		dl.Fatal("get database")
	}

	// read cf from stdin
	cf, err := ioutil.ReadAll(os.Stdin)

	if err != nil {
		dl.Fatal("could not read cf: %v", err)
	}

	setConf(args[1], 0, cf)

}

func shutdown() {

	_, err := ac.RPC().ShutDown(context.Background(), &acproto.ACPY2Empty{})

	if err != nil {
		dl.Fatal("cannot shut down server: %v", err)
	}
}

// synthesize an empty ring config
func emptyCf() []byte {

	rc := &ringcf.Ring{
		Version: ringcf.VERSION,
		Parts: []ringcf.Part{
			{Shard: []uint32{0}},
		},
	}

	res, _ := ringcf.ToBytes(rc)
	res = append([]byte("# config not found\n# autogenerated example\n"), res...)
	return res
}

//################################################################

func getDBConf(dbname string) (*ringcf.Ring, uint64, error) {

	dbcf, ver, err := getConf(dbname)
	if err != nil {
		dl.Fatal("error: %v", err)
	}

	if dbcf == nil {
		return &ringcf.Ring{}, 0, nil
	}
	rcf, err := ringcf.FromBytes(dbcf)
	if err != nil {
		dl.Fatal("error: %v", err)
	}

	return rcf, ver, nil
}

func putDBConf(dbname string, rcf *ringcf.Ring, ver uint64) error {
	if dryRun {
		return nil
	}

	rcf.Version = ringcf.VERSION
	buf, err := ringcf.ToBytes(rcf)
	if err != nil {
		dl.Fatal("%v", err)
	}

	setConf(dbname, ver, buf)

	return nil
}

//################################################################

func cmdShard(args []string) {

	if len(args) < 2 {
		dl.Fatal("usage: dbname on/off/#replicas")
	}

	dbname := args[1]
	rcf, rcver, err := getDBConf(dbname)

	if err != nil {
		// RSN - usage
		dl.Fatal("error: %v", err)
	}

	if len(args) == 2 {
		// display config
		showRingConf(dbname, rcf, rcver)
		return
	}

	if args[2] == "off" {
		if rcf.Replicas == 0 {
			dl.Verbose("already off")
			return
		}
		dl.Verbose("disabling sharding for '%s'", dbname)
		rcf.Replicas = 0
		rcf.Parts = nil
		rcf.AutoShard = false
		putDBConf(dbname, rcf, rcver)
		return
	}

	if args[2] == "auto" {
		if rcf.Replicas == 0 {
			rcf.Replicas = 2
		}
		rcf.AutoShard = true
		putDBConf(dbname, rcf, rcver)
		return
	}
	if args[2] == "noauto" {
		rcf.AutoShard = false
		putDBConf(dbname, rcf, rcver)
		return
	}

	if args[2] == "on" {
		if rcf.Replicas == 0 {
			rcf.Replicas = 2
		}
	} else {
		n, _ := strconv.Atoi(args[2])

		if n == 0 {
			dl.Fatal("to disable sharding, use 'off'")
		}
		rcf.Replicas = n
	}

	err = updateRing(dbname, rcf)
	if err != nil {
		dl.Fatal("error: %v", err)
	}

	dl.Verbose("> %#v", rcf)
	putDBConf(dbname, rcf, rcver)
}

func updateRing(dbname string, rcf *ringcf.Ring) error {

	const numNums = 4

	// build list of all servers
	// build list of servers on ring

	dbServers := serversForDB(dbname)
	rgServers := serversOnRing(rcf)

	// copy + remove servers already configured
	var newParts []ringcf.Part

	for name, si := range dbServers {
		if ri, ok := rgServers[name]; ok {
			ri.Datacenter = si.Datacenter // update to current value
			ri.Rack = si.Rack
			newParts = append(newParts, *ri)
			delete(dbServers, name)
			delete(rgServers, name)
		}
	}

	// reuse the shard#s from removed servers - less turmoil
	var useNums []uint32
	for name, pi := range rgServers {
		for _, sn := range pi.Shard {
			useNums = append(useNums, sn)
		}
		dl.Verbose("removing %s", name)
	}

	// add new servers
	for name, si := range dbServers {
		dl.Verbose("adding %s", name)

		nums := make([]uint32, numNums)
		for i := 0; i < numNums; i++ {
			if len(useNums) != 0 {
				nums[i] = useNums[0]
				useNums = useNums[1:]
			} else {
				nums[i] = random()
			}
		}

		newParts = append(newParts, ringcf.Part{
			Server:     name,
			Datacenter: si.Datacenter,
			Rack:       si.Rack,
			Shard:      nums,
		})
	}

	rcf.Parts = newParts

	// how many bits?
	ns := len(newParts) * numNums * 4
	rbits := int(math.Ceil(math.Log2(float64(ns))))
	if rbits < 8 {
		rbits = 8
	}
	rcf.RingBits = rbits

	return nil
}

func random() uint32 {

	b := make([]byte, 4)
	if _, err := rand.Reader.Read(b); err != nil {
		dl.Fatal("%v", err)
	}

	return binary.LittleEndian.Uint32(b)
}

func serversForDB(dbname string) map[string]*info.Server {

	res := make(map[string]*info.Server)

	for name, si := range sinfo {
		for _, dbn := range si.Database {
			if dbn == dbname {
				res[name] = si
			}
		}
	}
	return res
}

func serversOnRing(rcf *ringcf.Ring) map[string]*ringcf.Part {

	res := make(map[string]*ringcf.Part)

	for _, p := range rcf.Parts {
		cp := p
		res[p.Server] = &cp
	}

	return res
}

func showRingConf(dbname string, rcf *ringcf.Ring, rcver uint64) {

	res, _ := ac.GetRingConf(dbname, "*")

	ff := "    %-10s: %v\n"

	fmt.Printf("%s\n", dbname)
	fmt.Printf(ff, "replicas", rcf.Replicas)
	fmt.Printf(ff, "ringbits", rcf.RingBits)
	fmt.Printf(ff, "autoshard", rcf.AutoShard)
	fmt.Printf(ff, "version", res.Vers)

	if rcver != res.Vers {
		fmt.Printf(ff, "pending", rcver)
	}
	if rcf.Replicas > 0 {
		if res.Stable {
			fmt.Printf(ff, "partitions", "stable")
		} else {
			fmt.Printf(ff, "partitions", "repartitioning")
		}
	}

	for _, p := range rcf.Parts {
		fmt.Printf("      %-40s %v\n", p.Server, p.Shard)
	}

	//fmt.Printf("%#v\n", rcf)
	//fmt.Printf("%#v\n", res)
}
